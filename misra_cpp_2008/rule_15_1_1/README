MISRA C++ 2008 Rule 15.1.1
The assignment-expression of a throw statement shall not itself cause
an exception to be thrown.

Take bad2 as an example:

```c++
#include <cstdio>

int counter = 0;

struct E {
    E() { if(counter > 0) { throw 10; }
          ++counter; } };

void f() { throw E(); }

int g() {
    try { f(); }
    catch (int e) { return e; }
    catch (E e) { return 0; }
    return 1; }

int main() {
    printf("%d\n", g());
    printf("%d\n", g()); }
```

```shell
$ clang -c -Wall -Wextra -o bad.o bad.cc
$ clang++ -o bad bad.o
$ ./bad
0
10
```

In this example, f throws E() directly, and the programmer calls f()
twice. The programmer might expect that the same exception would be
thrown both times. The result is that different exceptions will be
thrown both times.

> If an exception is thrown when constructing the exception object,
> or when evaluating the assignment expression that initializes the
> exception object, it is that exception thart propagates in preference
> to the one that was about to be thrown.
