MISRA C++ 2008 Rule 3-2-2
The One Definition Rule shall not be violated.

- The definition of an object shall be exactly one.
- The definition of a non-inline function shall be exactly one.
- The definitions of an inline function shall be identical.
- The definitions of a type shall be identical.
- The definitions of a template shall be identical.

One Definition Rule
[basic.def.odr]

No translation unit shall contain more than one definition of any variable, function, class type, enumeration type or template.

An expression is potentially evaluated unless it appears where an integral constant expression is required
(see 5.19), is the operand of the sizeof operator (5.3.3), or is the operand of the typeid operator and
the expression does not designate an lvalue of polymorphic class type (5.2.8). An object or non-overloaded
function is used if its name appears in a potentially-evaluated expression. A virtual member function is
used if it is not pure. An overloaded function is used if it is selected by overload resolution when referred
to from a potentially-evaluated expression. [Note: this covers calls to named functions (5.2.2), operator
overloading (clause 13), user-defined conversions (12.3.2), allocation function for placement new (5.3.4),
as well as non-default initialization (8.5). A copy constructor is used even if the call is actually elided by
the implementation. ] An allocation or deallocation function for a class is used by a new expression appear-
ing in a potentially-evaluated expression as specified in 5.3.4 and 12.5. A deallocation function for a class
is used by a delete expression appearing in a potentially-evaluated expression as specified in 5.3.5 and 12.5.
A copy-assignment function for a class is used by an implicitly-defined copy-assignment function for
another class as specified in 12.8. A default constructor for a class is used by default initialization as speci-
fied in 8.5. A constructor for a class is used as specified in 8.5. A destructor for a class is used as specified
in 12.4.

Every program shall contain exactly one definition of every non-inline function or object that is used in that
program; no diagnostic required. The definition can appear explicitly in the program, it can be found in the
standard or a user-defined library, or (when appropriate) it is implicitly defined (see 12.1, 12.4 and 12.8).
An inline function shall be defined in every translation unit in which it is used.

Exactly one definition of a class is required in a translation unit if the class is used in a way that requires the
class type to be complete. [Example: the following complete translation unit is well-formed, even though it
never defines X:
     struct X;                                      // declare X as a struct type
     struct X* x1;                                  // use X in pointer formation
     X* x2;                                         // use X in pointer formation
 --end example] [Note: the rules for declarations and expressions describe in which contexts complete class
types are required. A class type T must be complete if:
-- an object of type T is defined (3.1, 5.3.4), or
-- an lvalue-to-rvalue conversion is applied to an lvalue referring to an object of type T (4.1), or
-- an expression is converted (either implicitly or explicitly) to type T (clause 4, 5.2.3, 5.2.7, 5.2.9, 5.4), or
-- an expression that is not a null pointer constant, and has type other than void *, is converted to the
  type pointer to T or reference to T using an implicit conversion (clause 4), a dynamic_cast (5.2.7) or
  a static_cast (5.2.9), or
-- a class member access operator is applied to an expression of type T (5.2.5), or
-- the typeid operator (5.2.8) or the sizeof operator (5.3.3) is applied to an operand of type T, or
-- a function with a return type or argument type of type T is defined (3.1) or called (5.2.2), or
-- an lvalue of type T is assigned to (5.17). ]

There can be more than one definition of a class type (clause 9), enumeration type (7.2), inline function
with external linkage (7.1.2), class template (clause 14), non-static function template (14.5.5), static data
member of a class template (14.5.1.3), member function of a class template (14.5.1.1), or template special-
ization for which some template parameters are not specified (14.7, 14.5.4) in a program provided that each
definition appears in a different translation unit, and provided the definitions satisfy the following require-
ments. Given such an entity named D defined in more than one translation unit, then
-- each definition of D shall consist of the same sequence of tokens; and
-- in each definition of D, corresponding names, looked up according to 3.4, shall refer to an entity defined
  within the definition of D, or shall refer to the same entity, after overload resolution (13.3) and after
  matching of partial template specialization (14.8.3), except that a name can refer to a const object
 with internal or no linkage if the object has the same integral or enumeration type in all definitions of D,
     and the object is initialized with a constant expression (5.19), and the value (but not the address) of the
     object is used, and the object has the same value in all definitions of D; and
-- in each definition of D, the overloaded operators referred to, the implicit calls to conversion functions,
  constructors, operator new functions and operator delete functions, shall refer to the same function, or to
  a function defined within the definition of D; and
-- in each definition of D, a default argument used by an (implicit or explicit) function call is treated as if
  its token sequence were present in the definition of D; that is, the default argument is subject to the three
  requirements described above (and, if the default argument has sub-expressions with default arguments,
  this requirement applies recursively).25)
-- if D is a class with an implicitly-declared constructor (12.1), it is as if the constructor was implicitly
  defined in every translation unit where it is used, and the implicit definition in every translation unit
  shall call the same constructor for a base class or a class member of D. [Example:
      // translation unit 1:
      struct X {
                  X(int);
                  X(int, int);
      };
      X::X(int = 0) { }
      class D: public X { };
      D d2;                                                 // X(int) called by D()

      // translation unit 2:
      struct X {
                  X(int);
                  X(int, int);
      };
      X::X(int = 0, int = 0) { }
      class D: public X { };                                // X(int, int) called by D();
                                                            // D()'s implicit definition
                                                            // violates the ODR
  --end example] If D is a template, and is defined in more than one translation unit, then the last four
 requirements from the list above shall apply to names from the template's enclosing scope used in the
 template definition (14.6.3), and also to dependent names at the point of instantiation (14.6.2). If the
 definitions of D satisfy all these requirements, then the program shall behave as if there were a single
 definition of D. If the definitions of D do not satisfy these requirements, then the behavior is undefined.
