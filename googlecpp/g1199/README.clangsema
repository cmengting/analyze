Clang 提供了丰富的 cast 检查，包括 overflow、符号翻转、精度截断等，从
third_party/llvm-project/clang/include/clang/Basic/DiagnosticSemaKinds.td:3809
warn_impcast_vector_scalar 开始。
一些其他的例子：

LiteralConversion
  值变化 warn_impcast_literal_float_to_integer
  Overflow warn_impcast_literal_float_to_integer_out_of_range
ImplicitIntConversion
  失精度  warn_impcast_integer_precision warn_impcast_integer_64_32
  比较复杂的行为，见下文 warn_impcast_high_order_zero_bits
ImplicitFloatConversion
  失精度 warn_impcast_float_precision warn_impcast_float_result_precision
  增精度 warn_impcast_double_promotion
ImplicitIntFloatConversion
  失精度 warn_impcast_integer_float_precision warn_impcast_integer_float_precision_constant
SignConversion
  符号翻转 warn_impcast_integer_sign warn_impcast_integer_sign_conditional
  结果总非负 warn_impcast_nonnegative_result
ConstantConversion
  值变化（符号翻转） warn_impcast_integer_precision_constant
  精度截断 warn_impcast_bitfield_precision_constant
FloatConversion
  值变化 warn_impcast_float_to_integer warn_impcast_float_to_integer_zero
  Overflow warn_impcast_float_to_integer_out_of_range


这些 diag 和 compiler option 的关系记录在
third_party/llvm-project/clang/include/clang/Basic/DiagnosticGroups.td 中。

=========================================

下面解释 warn_impcast_high_order_zero_bits 对应的问题，示例代码如下

unsigned int a = 1;
unsigned long k = -a;

这时得到的 k 会是 0xffffffff。首先 unsigned int a = 1，a == 0x1，而 unsigned int 的运
算是 modulo 2^32 次方的，于是 －a = 2^32-1 = 0xffffffff，
这时再取 unsigned long k = 0xffffffff，会使得 k 的高位用 0 补全，也就是 warning:
higher order bits are zeroes after implicit conversion [-Wimplicit-int-conversion]。

检查对应的代码是

if (TargetRange.Width > SourceTypeRange.Width) {
  if (auto *UO = dyn_cast<UnaryOperator>(E))
    if (UO->getOpcode() == UO_Minus)
      if (Source->isUnsignedIntegerType()) {
        if (Target->isUnsignedIntegerType())
          return DiagnoseImpCast(S, E, T, CC,
                                  diag::warn_impcast_high_order_zero_bits);
        if (Target->isSignedIntegerType())
          return DiagnoseImpCast(S, E, T, CC,
                                  diag::warn_impcast_nonnegative_result);
      }
}

=========================================

下面解释 warn_impcast_integer_precision_constant 对应的问题，示例代码如下

int16_t i16 = 32768;
int16_t i16x = 0x8000;

注意到 int16_t 的范围是 [-32768, -1] + [0, 32767] = [0x8000, 0xffff] + [0x0, 0x7fff]。
两行的 AST 是完全相同的，但是 i16 处会有 compiler err：

<source>:11:19: warning: implicit conversion from 'int' to 'int16_t' (aka 'short') changes value from 32768 to -32768 [-Wconstant-conversion]
    int16_t i16 = 32768;
            ~~~   ^~~~~
1 warning generated.

首先找到应该分析的代码，这个 warning 对应 warn_impcast_integer_precision_constant，
报出的位置是 SemaChecking.cpp CheckImplicitConversion

if (TargetRange.Width == LikelySourceRange.Width && !TargetRange.NonNegative && LikelySourceRange.NonNegative && Source->isSignedIntegerType()) {
    // Warn when doing a signed to signed conversion, warn if the positive
    // source value is exactly the width of the target type, which will
    // cause a negative value to be stored.

    Expr::EvalResult Result;
    if (E->EvaluateAsInt(Result, S.Context, Expr::SE_AllowSideEffects) && !S.SourceMgr.isInSystemMacro(CC)) {
      llvm::APSInt Value = Result.Val.getInt();
      if (isSameWidthConstantConversion(S, E, T, CC)) {
        std::string PrettySourceValue = toString(Value, 10);
        std::string PrettyTargetValue = PrettyPrintInRange(Value, TargetRange);

        S.DiagRuntimeBehavior(...);
        return;
      }
    }

    // Fall through for non-constants to give a sign conversion warning.
  }

// Helper function to filter out cases for constant width constant conversion.
// Don't warn on char array initialization or for non-decimal values.
static bool isSameWidthConstantConversion(Sema &S, Expr *E, QualType T, SourceLocation CC) {
  // If initializing from a constant, and the constant starts with '0',
  // then it is a binary, octal, or hexadecimal.  Allow these constants
  // to fill all the bits, even if there is a sign change.
  if (auto *IntLit = dyn_cast<IntegerLiteral>(E->IgnoreParenImpCasts())) {
    const char FirstLiteralCharacter =
        S.getSourceManager().getCharacterData(IntLit->getBeginLoc())[0];
    if (FirstLiteralCharacter == '0')
      return false;
  }

  ...

  return true;
}

所以答案是（1）通过 SourceManager.getCharacterData(loc)，
（2）对于 bin/oct/hex 的 constant, 即使发生了 sign change，
isSameWidthConstantConversion() 也返回 false，不报错。
